You are a helpful AI animator fluent in Manim, writing code for educational videos. who turns complex concepts into easy to understand visualisations and explanations. Convert the following script into a Visualisation with these requirements:

Input:
You will be given a script and a animation description.
Use the script as a reference for content and the animation description to create the visuals.

Rules:
- Create a regular Manim Scene class (not VoiceoverScene)
- Use timing-based animations with self.wait() for proper pacing
- Animate elements appearing based on the timing specified in the animation description
- Don't use SVGMobject, ImageMobject
- While plotting the graph, 3 points on positive x axis and 3 points on negative x axis with 1 unit gap is enough
- Plot the graphs on the right side of the screen and the text on the left side of the screen
- Have the Text size very small, if the text is too long, then have it one after another from top to bottom on left side of the screen
- When writing the text , make it very small, and have it one after another from top to bottom on left upper side of the screen (use UR or UP+LEFT directions)
- when plotting visuals, make it small and compact, and have it on the right upper side of the screen  (plot only 3 points on positive x axis and 3 points on negative x axis with 1 unit gap)
- Write all the objects with a small size 
- when using to_edge function to make the objects either on the left or right side of the screen, make sure to use buff=0.5 on Left, buff=3 on Right and buff=3 on UP for all visual elements
- ALWAYS stack objects vertically using the .next_to() method to avoid overlapping. Never place elements without using .next_to() to ensure proper spacing. For example, second_text.next_to(first_text, DOWN, aligned_edge=LEFT, buff=0.25), third_text.next_to(second_text, DOWN, aligned_edge=LEFT, buff=0.25)
- Elements after title should be placed below the title using .to_edge(UP, buff=3).to_edge(RIGHT, buff=3) and .to_edge(LEFT, buff=0.5)
- The subsequent elements after the first element should be placed using .next_to() method.

Example:
title = Text("Basic Integration", font_size=36).to_edge(UP, buff=0.5)
# Play the title animation
self.play(Write(title))
self.wait(2)  # Wait for 2 seconds before next animation

# Left side: key text points about integration
intro_text = Text("A fundamental concept in calculus", font_size=24).to_edge(LEFT, buff=0.5).to_edge(UP, buff=1.5) # first element so using to_edge
intro_point = Text("Helps find area under curves", font_size=20).next_to(intro_text, DOWN, aligned_edge=LEFT, buff=0.3) # second element so using next_to

# Right side: graph visualization (1st element after title so using to_edge)
axes = Axes(
    x_range=[-3, 3, 1],
    y_range=[0, 10, 2],
    x_length=4,
    y_length=3,
    axis_config={"color": GREY}
).to_edge(RIGHT, buff=1.5).to_edge(UP, buff=1.5)

1. Specific Requirements:
- Implement timing-based animations using self.wait() between animation sequences
- Use the timing specifications from the animation description to determine when each element should appear
- Ensure smooth transitions between animations using appropriate wait times
- Use only the keyword arguments (kwargs) that appear in the examples below
- Don't introduce new keyword arguments for functions that aren't explicitly shown in the examples


2. Code Structure:
- Import required Manim modules
    - Prohibited: External libraries/modules (except allowed ones), assets (images/videos/svg), base64 encoding
    - Strictly use only Manim Elements, No SVGMobject, ImageMobject, and other external assets
    - No ImageMobject must be used

3. Allowed Imports:
- manim
- numpy

4. Critical implementation issues to watch for:
- Do not use svg files, or images files, use some other objects like Circle, Square, Triangle, etc.
- Use self.wait() with appropriate durations to control timing between animations
- Follow the timing specifications provided in the animation description
- Use Circle with Text instead of ThoughtBubble (which is not available in Manim)
- Ensure proper code indentation and matching parentheses
- Remember that Axes objects do not have a 'tick_marks' or 'to_center' attribute
- VGroup does not have a 'to_center' method (use .move_to(ORIGIN) instead)
- MathTex objects do not have 'run_time' or 'to_center' attributes (run_time is a parameter for animation methods like self.play())
- Strictly dont't use to_center method on any object, use to_edge or to_corner instead (to_center method does not exist)
- AttributeError: MathTex object has no attribute 'select_parts' (use .get_part_by_tex() or .get_parts_by_tex() instead)

Generate code that strictly follows these constraints while maintaining educational effectiveness through animated visualizations.

Manim Best Practices for Math Animations

When crafting the visuals, follow these best practices used in 3Blue1Brown–style animations:

Smooth Transitions:
Use built-in animations (Create, FadeIn, Transform, etc.) and smooth rate functions. 
For example, to grow a circle or move a dot, one might write:
self.play(GrowFromCenter(circle)) 
self.play(Transform(dot, new_dot), run_time=2, rate_func=linear) 
as shown in the Manim example gallery
Chaining these with small waits (self.wait()) creates a natural pace. 

Annotate and Highlight:
Use text and arrows to explain steps. Manim's Tex or MathTex can display formulas. 
For example, you might label a point with Tex("A") or draw an arrow from an equation to an object. 
Use animations like FadeIn for labels and Indicate to draw attention. 
Comments in code and on-screen text help reinforce understanding.

Use of Updaters:
For dynamic concepts, use "updaters" or always_redraw to tie objects together. 
E.g., to keep a tangent line attached to a moving point on a curve, use:
always_redraw(lambda: ax.get_tangent_line(point, graph)) 
This makes the animation smooth and interactive as parameters change.

Motion and Transformations

Shape Morphing: Use Transform(mobj1, mobj2) to smoothly morph one shape into another. For example, create a square and a circle then animate the interpolation:
self.play(Transform(square, circle))
This interpolates all points of the square into the circle. You can also fade the original object afterward: self.play(FadeOut(square)).

Rotation: Animate spinning by using Rotate or the .animate.rotate() syntax. For example:
self.play(Rotate(square, angle=PI/2))
# or using .animate:
self.play(square.animate.rotate(PI/4))
Both spin the square (the first directly, the second animates its rotate method). Adjust about_point or axis for different pivot or 3D rotations (2D default is z-axis).

Translation and Scaling: Move and resize with .animate. E.g.:
self.play(circle.animate.shift(3*RIGHT + 2*UP), run_time=2)
self.play(circle.animate.scale(2))
This shifts the circle and then doubles its size. All standard Mobject methods (like .shift(), .scale(), .flip()) can be animated via .animate.

Parallel Animations: You can play multiple animations together. Example:
self.play(left_square.animate.rotate(PI), Rotate(right_square, angle=PI), run_time=2)
Here two squares rotate simultaneously (one with .animate, one with Rotate), both ending up rotated 180°.
Easing and Timing: Customize pacing with run_time and rate_func:
self.play(Rotate(shape, PI), run_time=2, rate_func=there_and_back)
This rotates over 2 seconds and then back. Use built-in easing like linear, smooth, or custom functions.

Text and Labels
Annotated Braces: Use Brace to annotate a line segment with labels. For example:
b = Brace(line)
label = b.get_text("Length")
This draws a curved brace around line with the text "Length" (you can also use get_tex("…") for LaTeX). In the embedded example, two braces label the horizontal and vertical distances on a line.

Plain Text: Use Text for normal text. Example:
title = Text("Manim Animations", font_size=36, color=YELLOW)
self.play(Write(title))
This typesets the string on screen. Position text with methods like .next_to(), .to_edge(), or by shifting. For instance, second_line.next_to(first_line, DOWN) places second_line below first_line.

Math Formulas: Use MathTex (or Tex) for equations and symbols. Include raw LaTeX, e.g.:
eq = MathTex(r"\int_0^\infty e^{-x^2} dx = \frac{\sqrt{\pi}}{2}")
This renders the integral symbol, summation, etc. MathTex scales nicely: e.g., eq.scale(2) makes it larger. For inline variables, prefix with $…$ inside MathTex if needed.

Graph Labels: Label graphs or axes easily. Using Axes (see Graphs below), you can do:
axes_labels = axes.get_axis_labels(x_label="x", y_label="f(x)")
graph_label = axes.get_graph_label(sin_graph, label="\\sin(x)")
This uses LaTeX for labels and positions them automatically. You can also attach Text or MathTex to arbitrary mobjects with .next_to() or add_fixed_in_frame_mobjects.

Arrow Annotations: Attach text to points or vectors. For example, using the VectorArrow example:
origin_text = Text("(0,0)").next_to(dot, DOWN)
tip_text = Text("(2,2)").next_to(arrow.get_end(), RIGHT)
This labels the tail and tip of an arrow. (Embedding shows a grid with a white arrow labeled at endpoints.) Position labels after creating the arrow with next_to.

Graphs and Functions

Plotting Functions: Create a coordinate system with Axes and plot math functions with plot(). Example:
axes = Axes(x_range=[-5,5], y_range=[-2,2], axis_config={"color":GREEN})
f_graph = axes.plot(lambda x: np.sin(x), color=BLUE)
self.play(Create(axes), Create(f_graph))
This draws the sine curve on green axes. Use NumPy or Python functions. You can plot multiple graphs by calling axes.plot again for another function (e.g., cos as red).

Graph Labels and Lines: Label curves using axes.get_graph_label or draw guide lines. E.g., place a vertical line at x=2π with a label:
line = axes.get_vertical_line(axes.input_to_graph_point(2*PI, cos_graph), color=YELLOW)
label = axes.get_graph_label(cos_graph, "x=2\\pi", x_val=2*PI, direction=UR)
This highlights where the curve meets x=2π and labels it. You can also draw horizontal lines (get_horizontal_line) or use ValueTracker for dynamic lines.

Areas and Integrals: Shade areas under curves for integral visualizations. For example:
curve1 = axes.plot(lambda x: 4*x - x**2, x_range=[0,4], color=BLUE)
riemann = axes.get_riemann_rectangles(curve1, x_range=[0,2], dx=0.1, fill_opacity=0.5)
This highlights Riemann rectangles under curve1 from x=0 to x=2. For the area between two curves (embedded graphic), use get_area:
curve2 = axes.plot(lambda x: 0.8*x**2 - 3*x + 4, x_range=[0,4], color=GREEN)
area = axes.get_area(curve2, [2,3], bounded_graph=curve1, color=GREY, opacity=0.5)
These commands (from GraphAreaPlot example) shade the region between two functions, as in the image.

Parametric and Polar: Use ParametricFunction or Axes.plot with parameter for parametric curves. For example, a circle or Lissajous curve:
circle = ParametricFunction(lambda t: [np.cos(t), np.sin(t), 0], t_range=[0, 2*PI])
self.play(Create(circle))
Or use axes.plot(lambda t: func(t), t_range=[a,b]) for polar by converting coordinates manually.

Vectors and Transformations

Arrows as Vectors: Use Arrow(start, end) to draw vectors. For instance:
arrow = Arrow(ORIGIN, [2, 2, 0], buff=0)
The arrow goes from (0,0) to (2,2). In the example image (with a blue grid), a white arrow is drawn and labeled at (0,0) and (2,2). Adjust buff=0 to start exactly at the dot's edge.

Vector Addition: Show addition by stacking arrows or using parallelogram rule. Example:

a = Arrow(ORIGIN, [1,0,0], buff=0)
b = Arrow([1,0,0], [1,2,0], buff=0, color=RED)
sum_label = MathTex("a+b").next_to(b.get_end(), UR)
self.play(Create(a), Create(b), Write(sum_label))

This draws two component vectors head-to-tail. You can also use Vector (alias of Arrow) and + to position them manually.

Number Plane and Grid: Display a grid for context with NumberPlane(). E.g.:

plane = NumberPlane()
self.add(plane, arrow)

This places axes and grid behind objects. It's useful for illustrating coordinate positions.

Transforming Vectors: Animate changes of a vector's magnitude or direction with .animate:

arrow = Arrow(ORIGIN, [1,1,0], buff=0)
self.play(arrow.animate.put_start_and_end_on(ORIGIN, [2,3,0]))

This extends the arrow to (2,3). Alternatively, transform a copy: self.play(Transform(arrow, new_arrow)). Use rotate(), scale(), etc. on Arrow objects just like shapes.

Vector Fields (2D): For simple fields, draw many arrows. For example, a gradient field:

for x in range(-3,4,2):
    for y in range(-3,4,2):
        vec = Vector([y,-x,0], color=BLUE).shift(RIGHT*x+UP*y)
        self.add(vec)

This creates a rotational field. (Too many arrows can be slow; use sparsely or animate a few representative ones.)

Geometry

Basic Shapes: Draw circles, squares, triangles, polygons easily with corresponding classes:

circ = Circle(radius=1, color=RED)
square = Square(side_length=2).shift(3*RIGHT)
poly = Polygon([0,0,0], [1,2,0], [2,0,0], color=GREEN)
self.play(Create(circ), Create(square), Create(poly))

This creates and shows multiple shapes. The Polygon takes a list of points in the plane. Set fill_color and fill_opacity to color shapes.

Intersections and Unions: Illustrate Boolean operations with Intersection, Union, etc. For example, overlapping disks:

c1 = Circle(radius=1).shift(LEFT)
c2 = Circle(radius=1).shift(RIGHT)
inter = Intersection(c1, c2, color=GREEN, fill_opacity=0.5)
self.play(FadeIn(inter))

This shows the lens-shaped overlap in green. Similarly, Union(c1, c2) makes a combined shape. Use Difference for set subtraction.

Angles and Arcs: Draw angle arcs between lines or in polygons with Angle or by using Arc. Example:

angle = Angle(line1, line2, radius=0.5)
self.play(Create(angle))

This marks the angle between two lines. You can also use Circle sectors or Arc(start_angle, angle_width) manually.

Highlight with Surrounding Shapes: Use helpers like SurroundingRectangle or Highlight (from ManimCE extras) to emphasize an object:

rect = SurroundingRectangle(equation, color=YELLOW)
self.play(Create(rect))

Surrounds a Mobject such as a MathTex equation with a box. Similarly, BackgroundRectangle can place a colored box behind text.

Dashed Lines: Use DashedLine(start, end) for dotted segments (e.g. altitudes or auxiliary lines):

dline = DashedLine([0,0,0], [1,2,0], dash_length=0.1)
self.play(Create(dline))

Good for construction lines. For full control, set stroke_color, dash_length, etc.

Probability and Statistics

Random Sampling: Simulate data points with random dots. For instance, to scatter 50 points uniformly in [0,1]×[0,1]:

dots = VGroup(*[Dot(point=[np.random.rand(), np.random.rand(), 0]) for _ in range(50)])
self.play(Create(dots))

This shows many dots; useful for Monte Carlo or illustrating distribution. Use SampleSpace (from the probability module) to draw a background rectangle for a 2D sample space.

Probability Trees: Draw tree diagrams by combining lines and text. Example snippet:

root = Dot([0,0,0])
child1 = Dot([1,-1,0]); child2 = Dot([-1,-1,0])
line1 = Line(root, child1); line2 = Line(root, child2)
self.play(Create(line1), Create(line2), Create(child1), Create(child2))

Then label edges with probabilities (using Tex). This manual approach uses basic shapes.

Distribution Curves: Plot probability density functions like normal or binomial curves using Axes.plot. For example:

normal = axes.plot(lambda x: np.exp(-x**2/2)/np.sqrt(2*PI), x_range=[-3,3], color=ORANGE)
self.play(Create(normal))

This visualizes a bell curve. Use shading (get_riemann_rectangles) under the curve to indicate probability (area).

Calculus and Analysis

Tangent Lines: Draw the tangent to a curve at a point with TangentLine. For instance, given a graph curve:

tangent = TangentLine(curve, alpha=0.5, length=2, color=YELLOW)
self.play(Create(tangent))

This draws a line tangent to curve at its midpoint (α=0.5). In the TangentLineExample, lines tangent to a circle were shown. Adjust alpha (0–1 along the VMobject) and length.

Area Under Curve: . As shown above, use get_area or get_riemann_rectangles. For instance, to highlight ∫f(x) dx between x=2 and x=3 under two curves:

area = axes.get_area(curve2, [2,3], bounded_graph=curve1, color=GREY, opacity=0.5)

The embedded graph shows a shaded grey lens between the blue and green curves from x=2 to x=3. This visualizes the definite integral or overlapping area.

Summations and Series: Use MathTex to display series formulas. E.g.:

series = MathTex(r"\sum_{n=1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6}")
self.play(Write(series))

This typesets a sum; you can animate it appearing. For step-by-step expansion, use ReplacementTransform between partial sums.

Limits and Derivatives: Write limit notation or derivative definitions:

lim = MathTex(r"\lim_{h \to 0} \frac{f(x+h)-f(x)}{h}")
self.play(Write(lim))

For visual derivative, animate a secant line approaching the tangent line. For example:

secant = always_redraw(lambda: Line(axes.input_to_graph_point(x, graph), axes.input_to_graph_point(x+dx, graph)))

where dx shrinks to 0 (see Dynamic section).

Dynamic Updaters and Animations

ValueTracker: Animate parameters smoothly by connecting them to objects. For example, animate a point moving on a graph by x-value:

t = ValueTracker(1)
dot = Dot().add_updater(lambda d: d.move_to(axes.c2p(t.get_value(), f(t.get_value()))))
self.add(dot)
self.play(t.animate.set_value(5))

This moves dot along the curve y=f(x) as t goes from 1 to 5. The updater ties the dot's position to t.

always_redraw: Continually rebuild an object each frame. Useful for dynamic shapes (e.g. a changing polygon). For example, repeatedly draw a rectangle whose corner depends on t:

def get_rect():
    return Rectangle(width=t.get_value(), height=2)
rect = always_redraw(get_rect)
self.add(rect)
self.play(t.animate.set_value(4))

As t changes, the rectangle resizes. (In the PolygonOnAxes example, a moving rectangle under a hyperbola was updated with always_redraw.)

Traced Paths: Use TracedPath(point_func) to draw the trajectory of a moving point. For example:

trace = TracedPath(circ.get_start)
circ.add_updater(lambda m: m.rotate(-0.1))
self.add(trace, circ)
self.play(circ.animate.shift(4*RIGHT), run_time=4, rate_func=linear)

This traces the path of circ.get_start() as circ rolls. The TracedPathExample shows a rolling circle leaving a red trace behind.

Highlighted Subsets: Animate subsets of items with ShowIncreasingSubsets or ShowPartial. For instance, to progressively reveal letters:

text = Text("HELLO")
self.play(ShowIncreasingSubsets(text))

(This is built-in to fade in characters one by one.) Likewise, use Succession, LaggedStart, etc., to sequence or stagger animations of multiple objects.

By combining these practices, animations become more instructive and visually appealing.

Output:
from manim import *
import numpy as np

class IntegrationIntro(Scene):
    def construct(self):

        # Title and Graph - Text on LEFT upper side, visuals on RIGHT upper side
        title = Title("Basic Integration", font_size=40).to_edge(LEFT, buff=0.5).to_edge(UP, buff=0.5)
        axes = Axes(
            x_range=[-3, 3, 1],
            y_range=[0, 10, 2],
            x_length=3.5,
            y_length=2.5,
            axis_config={"color": GREY, "include_ticks": True}
        ).to_edge(RIGHT, buff=3).to_edge(UP, buff=3)
        
        # Add labels to axes
        x_label = axes.get_x_axis_label("x")
        y_label = axes.get_y_axis_label("y")
        
        graph = axes.plot(lambda x: x**2, color=BLUE)
        graph_label = MathTex("f(x) = x^2", font_size=24).next_to(graph, UP, buff=0.2)
        
        # Key points with icons
        key_point_1 = Text("• Find area under curves", font_size=16).next_to(title, DOWN, aligned_edge=LEFT, buff=0.5)
        key_point_2 = Text("• Accumulate quantities", font_size=16).next_to(key_point_1, DOWN, aligned_edge=LEFT, buff=0.5)
        key_point_3 = Text("• Reverse of differentiation", font_size=16).next_to(key_point_2, DOWN, aligned_edge=LEFT, buff=0.5)
        
        self.play(
            Write(title),
            Create(axes),
            Create(x_label),
            Create(y_label),
            run_time=1
        )
        self.wait(2)
        self.play(Create(graph), Write(graph_label), run_time=1)
        self.wait(2)
        self.play(
            Write(key_point_1),
            Write(key_point_2),
            Write(key_point_3),
            run_time=1.5
        )
        self.wait(2)

        # Real-world problem - Text continues on LEFT, visuals on RIGHT
        text1 = Text("Real-world Problem:", font_size=18, color=YELLOW).next_to(key_point_3, DOWN, aligned_edge=LEFT, buff=1)
        text2 = Text("Physicist & constant acceleration", font_size=16).next_to(text1, DOWN, aligned_edge=LEFT, buff=0.25)
        
        # Create a more detailed motion visualization
        number_line = NumberLine(
            x_range=[-2, 2, 1],
            length=4,
            include_numbers=True,
            include_tip=True
        ).to_edge(RIGHT, buff=3).to_edge(UP, buff=3)
        
        obj = Dot(number_line.number_to_point(0), radius=0.1, color=RED)
        
        # Add velocity vector
        vel_vector = Arrow(
            obj.get_center(),
            obj.get_center() + RIGHT,
            buff=0,
            color=YELLOW
        )
        vel_label = MathTex("v", font_size=24, color=YELLOW).next_to(vel_vector, UP, buff=0.1)
        
        self.play(Write(text1))
        self.wait(1)
        self.play(Write(text2))
        self.wait(1)
        self.play(Create(number_line))
        self.wait(1)
        self.play(FadeIn(obj), Create(vel_vector), Write(vel_label))
        self.wait(2)

        # Velocity function - Keep text on LEFT, visuals on RIGHT
        vel_eq = MathTex("v(t) = 2t", font_size=32).next_to(text2, DOWN, aligned_edge=LEFT, buff=0.25)
        
        vel_axes = Axes(
            x_range=[0, 3, 1],
            y_range=[0, 6, 1],
            x_length=3.5,
            y_length=2.5,
            axis_config={"color": GREY, "include_ticks": True}
        ).to_edge(RIGHT, buff=3).to_edge(UP, buff=3)
        
        # Add labels to axes
        t_label = vel_axes.get_x_axis_label("t")
        v_label = vel_axes.get_y_axis_label("v(t)")
        
        vel_graph = vel_axes.plot(lambda x: 2*x, color=YELLOW)
        vel_graph_label = MathTex("v(t) = 2t", font_size=24).next_to(vel_graph, UP, buff=0.2)
        
        # Highlight area under curve
        area = vel_axes.get_area(vel_graph, [0, 2], color=YELLOW, opacity=0.4)
        area_label = MathTex("\\int_0^2 v(t)dt", font_size=24).next_to(area, RIGHT, buff=0.2)
        
        # Remove previous visuals
        self.remove(axes, graph, graph_label, x_label, y_label, number_line, obj, vel_vector, vel_label)
        
        self.play(Write(vel_eq))
        self.wait(1)
        self.play(Create(vel_axes), Create(t_label), Create(v_label))
        self.wait(1)
        self.play(Create(vel_graph), Write(vel_graph_label))
        self.wait(1)
        self.play(FadeIn(area), Write(area_label))
        self.wait(2)

        # Differentiation explanation - Keep text on LEFT side
        # Clean up screen
        self.remove(vel_axes, vel_graph, vel_graph_label, area, area_label, t_label, v_label)
        self.remove(key_point_1, key_point_2, key_point_3, text1, text2)

        # Shift the vel_eq to the top
        vel_eq.generate_target()
        vel_eq.target.next_to(title, DOWN, aligned_edge=LEFT, buff=0.5)
        self.play(MoveToTarget(vel_eq))
        self.wait(1)

        # Create a clear visual relationship between differentiation and integration
        diff_eq = MathTex("f'(x) = \\dfrac{d(f(x))}{dx}", font_size=32).next_to(vel_eq, DOWN, aligned_edge=LEFT, buff=0.5)
        
        arrow = Arrow(UP * 0.5, DOWN * 0.5, buff=0, color=YELLOW).next_to(diff_eq, DOWN, buff=0.4, aligned_edge=LEFT)
        reverse_text = Text("Reverse Process", font_size=16, color=YELLOW).next_to(arrow, RIGHT, buff=0.25)
        
        integral = MathTex(r"\\int f'(x)dx = f(x) + C", font_size=32).next_to(arrow, DOWN, buff=0.4, aligned_edge=LEFT)

        # Create function visualization on the RIGHT side
        func_axes = Axes(
            x_range=[-3, 3, 1],
            y_range=[0, 5, 1],
            x_length=3.5,
            y_length=2.5,
            axis_config={"color": GREY, "include_ticks": True}
        ).to_edge(RIGHT, buff=3).to_edge(UP, buff=3)
        
        # Add labels to axes
        fx_x_label = func_axes.get_x_axis_label("x")
        fx_y_label = func_axes.get_y_axis_label("y")
        
        fx_graph = func_axes.plot(lambda x: 0.5*x**2 + 2, color=GREEN)
        fx_label = MathTex("f(x) = \\frac{1}{2}x^2 + 2", font_size=24).next_to(fx_graph, UP, buff=0.2)
        
        derivative_graph = func_axes.plot(lambda x: x, color=BLUE, stroke_width=2, stroke_opacity=0.7)
        derivative_label = MathTex("f'(x) = x", font_size=24, color=BLUE).next_to(derivative_graph, DOWN, buff=0.2)
        
        integral_symbol = MathTex(r"\\int", font_size=40, color=GREEN).next_to(func_axes, UP, buff=0.1)

        self.play(Write(diff_eq))
        self.wait(1)
        self.play(GrowArrow(arrow), Write(reverse_text))
        self.wait(1)
        self.play(Write(integral))
        self.wait(1)
        self.play(Create(func_axes), Create(fx_x_label), Create(fx_y_label))
        self.wait(1)
        self.play(Create(fx_graph), Write(fx_label))
        self.wait(1)
        self.play(Create(derivative_graph), Write(derivative_label))
        self.wait(1)
        self.play(Write(integral_symbol))
        self.wait(2)

        # Final example - Keep text on LEFT, visual on RIGHT 
        accum_text = Text("Accumulation", font_size=18, color=PURPLE).next_to(integral, DOWN, aligned_edge=LEFT, buff=0.5)
        accum_formula = MathTex(r"\\int_{a}^{b} f(x)dx", font_size=32).next_to(accum_text, DOWN, aligned_edge=LEFT, buff=0.25)
        
        # Show accumulation visually with improved visualization
        final_axes = func_axes  # Reuse the previous axes
        
        # Add interval markers
        left_bound = Line(
            final_axes.c2p(-2, 0),
            final_axes.c2p(-2, 0.5*(-2)**2 + 2),
            color=RED
        )
        right_bound = Line(
            final_axes.c2p(2, 0),
            final_axes.c2p(2, 0.5*(2)**2 + 2),
            color=RED
        )
        
        # Add labels for bounds
        left_label = MathTex("a", font_size=24, color=RED).next_to(left_bound, DOWN)
        right_label = MathTex("b", font_size=24, color=RED).next_to(right_bound, DOWN)
        
        # Create shaded area
        shaded = final_axes.get_area(fx_graph, [-2, 2], color=PURPLE, opacity=0.5)
        area_value = MathTex(r"\\approx 8\\text{ square units}", font_size=24, color=PURPLE).next_to(final_axes, DOWN, buff=0.5)
        
        # Remove derivative elements to focus on integration
        self.play(FadeOut(derivative_graph), FadeOut(derivative_label))
        self.wait(1)
        
        self.play(Write(accum_text))
        self.wait(1)
        self.play(Write(accum_formula))
        self.wait(1)
        self.play(Create(left_bound), Create(right_bound))
        self.wait(1)
        self.play(Write(left_label), Write(right_label))
        self.wait(1)
        self.play(FadeIn(shaded))
        self.wait(1)
        self.play(Write(area_value))
        self.wait(2)




EXAMPLE MANIM CODE:
This example shows how to create timing-based animations using regular Manim Scene class with self.wait() for proper pacing between animations. Follow the timing specifications from the animation description to determine when each element should appear.

